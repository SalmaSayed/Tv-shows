import { isNumber, isArray, innerTextTrim } from "cx/util";
import { PureContainer, VDOM, Widget, ResizeManager } from "cx/ui";

var Rect =
	/*#__PURE__*/
	(function() {
		function Rect(config) {
			Object.assign(this, config);
		}

		var _proto = Rect.prototype;

		_proto.width = function width() {
			return this.r - this.l;
		};

		_proto.height = function height() {
			return this.b - this.t;
		};

		_proto.valid = function valid() {
			return this.r > this.l && this.b > this.t;
		};

		_proto.makeValid = function makeValid() {
			return new Rect({
				l: Math.min(this.l, this.r),
				r: Math.max(this.l, this.r),
				t: Math.min(this.t, this.b),
				b: Math.max(this.t, this.b)
			});
		};

		_proto.isEqual = function isEqual(r) {
			if (!r || !r.isRect) return false;
			return r.l == this.l && r.r == this.r && r.t == this.t && r.b == this.b;
		};

		Rect.add = function add(a, b) {
			return new Rect({
				l: a.l + b.l,
				t: a.t + b.t,
				r: a.r + b.r,
				b: a.b + b.b
			});
		};

		Rect.multiply = function multiply(a, b) {
			return new Rect({
				l: a.l + (a.r - a.l) * b.l,
				r: a.l + (a.r - a.l) * b.r,
				t: a.t + (a.b - a.t) * b.t,
				b: a.t + (a.b - a.t) * b.b
			});
		};

		Rect.margin = function margin(r, m) {
			var mr = Rect.convertMargin(m);
			return Rect.add(r, mr);
		};

		Rect.convertMargin = function convertMargin(m) {
			if (!m) return new Rect();
			if (m.isRect) return m;
			if (isNumber(m))
				return new Rect({
					l: m,
					t: m,
					r: -m,
					b: -m
				});
			var m = Rect.convert(m);
			m.b = -m.b;
			m.r = -m.r;
			return m;
		};

		Rect.convert = function convert(r) {
			if (!r)
				return new Rect({
					l: 0,
					r: 0,
					t: 0,
					b: 0
				});
			if (r.isRect) return r;
			if (typeof r === "string") r = r.split(" ");

			if (isArray(r)) {
				return new Rect({
					t: parseFloat(r[0]),
					r: parseFloat(r[1]),
					b: parseFloat(r[2]),
					l: parseFloat(r[3])
				});
			}

			return new Rect(r);
		};

		return Rect;
	})();
Rect.prototype.isRect = true;
Rect.prototype.l = 0; //left;

Rect.prototype.r = 0; //right

Rect.prototype.t = 0; //top

Rect.prototype.b = 0; //bottom

function _defineProperty(obj, key, value) {
	if (key in obj) {
		Object.defineProperty(obj, key, {
			value: value,
			enumerable: true,
			configurable: true,
			writable: true
		});
	} else {
		obj[key] = value;
	}

	return obj;
}

function _objectSpread(target) {
	for (var i = 1; i < arguments.length; i++) {
		var source = arguments[i] != null ? arguments[i] : {};
		var ownKeys = Object.keys(source);

		if (typeof Object.getOwnPropertySymbols === "function") {
			ownKeys = ownKeys.concat(
				Object.getOwnPropertySymbols(source).filter(function(sym) {
					return Object.getOwnPropertyDescriptor(source, sym).enumerable;
				})
			);
		}

		ownKeys.forEach(function(key) {
			_defineProperty(target, key, source[key]);
		});
	}

	return target;
}

function _inheritsLoose(subClass, superClass) {
	subClass.prototype = Object.create(superClass.prototype);
	subClass.prototype.constructor = subClass;
	subClass.__proto__ = superClass;
}

var BoundedObject =
	/*#__PURE__*/
	(function(_PureContainer) {
		_inheritsLoose(BoundedObject, _PureContainer);

		function BoundedObject() {
			return _PureContainer.apply(this, arguments) || this;
		}

		var _proto = BoundedObject.prototype;

		_proto.declareData = function declareData() {
			var _PureContainer$protot;

			return (_PureContainer$protot = _PureContainer.prototype.declareData).call.apply(
				_PureContainer$protot,
				[
					this,
					{
						anchors: undefined,
						offset: undefined,
						margin: undefined,
						padding: undefined
					}
				].concat(Array.prototype.slice.call(arguments))
			);
		};

		_proto.prepareData = function prepareData(context, instance) {
			_PureContainer.prototype.prepareData.call(this, context, instance);

			var data = instance.data;
			data.anchors = Rect.convert(data.anchors);
			data.offset = Rect.convert(data.offset);
			data.margin = Rect.convertMargin(data.margin);
			data.padding = Rect.convertMargin(data.padding);
		};

		_proto.calculateBounds = function calculateBounds(context, instance) {
			var data = instance.data;
			return Rect.add(Rect.add(Rect.multiply(instance.parentRect, data.anchors), data.offset), data.margin);
		};

		_proto.prepareBounds = function prepareBounds(context, instance) {
			var data = instance.data;

			if (
				instance.shouldUpdate ||
				!instance.cached.parentRect ||
				!instance.cached.parentRect.isEqual(context.parentRect) ||
				!data.bounds
			) {
				if (!context.parentRect) throw new Error("Parent bounds were not provided through the context.");
				instance.parentRect = context.parentRect;
				instance.cache("parentRect", context.parentRect);
				instance.markShouldUpdate(context);
				data.bounds = this.calculateBounds(context, instance);
				data.childrenBounds = Rect.add(data.bounds, data.padding);
			}
		};

		_proto.prepare = function prepare(context, instance) {
			this.prepareBounds(context, instance);
			context.push("parentRect", instance.data.childrenBounds);
		};

		_proto.prepareCleanup = function prepareCleanup(context, instance) {
			context.pop("parentRect");
		};

		return BoundedObject;
	})(PureContainer);
BoundedObject.prototype.anchors = 0;
BoundedObject.prototype.margin = 0;
BoundedObject.prototype.offset = 0;
BoundedObject.prototype.padding = 0;
BoundedObject.prototype.isPureContainer = false;
BoundedObject.prototype.styled = true;

var Text =
	/*#__PURE__*/
	(function(_BoundedObject) {
		_inheritsLoose(Text, _BoundedObject);

		function Text() {
			return _BoundedObject.apply(this, arguments) || this;
		}

		var _proto = Text.prototype;

		_proto.declareData = function declareData() {
			var _BoundedObject$protot;

			return (_BoundedObject$protot = _BoundedObject.prototype.declareData).call.apply(
				_BoundedObject$protot,
				[this].concat(Array.prototype.slice.call(arguments), [
					{
						value: undefined,
						dx: undefined,
						dy: undefined,
						textAnchor: undefined,
						fill: undefined,
						stroke: undefined
					}
				])
			);
		};

		_proto.init = function init() {
			if (this.ta) this.textAnchor = this.ta;

			if (this.bind) {
				this.value = {
					bind: this.bind
				};
			} else if (this.tpl) {
				this.value = {
					tpl: this.tpl
				};
			} else if (this.expr) {
				this.value = {
					expr: this.expr
				};
			}

			_BoundedObject.prototype.init.call(this);
		};

		_proto.render = function render(context, instance, key) {
			var data = instance.data;
			var bounds = data.bounds;
			return VDOM.createElement(
				"text",
				{
					key: key,
					className: data.classNames,
					x: bounds.l,
					y: bounds.t,
					dx: data.dx,
					dy: data.dy,
					textAnchor: data.textAnchor,
					style: data.style,
					fill: data.fill,
					stroke: data.stroke
				},
				data.value,
				this.renderChildren(context, instance)
			);
		};

		return Text;
	})(BoundedObject);
Text.prototype.anchors = "0.5 0.5 0.5 0.5";
Text.prototype.baseClass = "text";
Widget.alias("svg.text", Text);

var TextualBoundedObject =
	/*#__PURE__*/
	(function(_BoundedObject) {
		_inheritsLoose(TextualBoundedObject, _BoundedObject);

		function TextualBoundedObject() {
			return _BoundedObject.apply(this, arguments) || this;
		}

		var _proto = TextualBoundedObject.prototype;

		_proto.add = function add(widget) {
			if (typeof widget != "string") return _BoundedObject.prototype.add.apply(this, arguments);
			if (this.trimWhitespace) widget = innerTextTrim(widget);
			if (!widget) return;
			return this.add({
				type: Text,
				value: widget,
				textAnchor: "middle",
				dy: "0.4em"
			});
		};

		return TextualBoundedObject;
	})(BoundedObject);

var Svg =
	/*#__PURE__*/
	(function(_BoundedObject) {
		_inheritsLoose(Svg, _BoundedObject);

		function Svg() {
			return _BoundedObject.apply(this, arguments) || this;
		}

		var _proto = Svg.prototype;

		_proto.initState = function initState(context, instance) {
			var size = {
				width: 0,
				height: 0
			};
			instance.state = {
				size: size
			};
		};

		_proto.prepare = function prepare(context, instance) {
			var size = instance.state.size;
			context.parentRect = new Rect({
				l: 0,
				t: 0,
				r: size.width,
				b: size.height
			});
			instance.clipRects = {};
			instance.clipRectId = 0;
			context.push("addClipRect", function(rect) {
				var id = "clip-" + instance.id + "-" + ++instance.clipRectId;
				instance.clipRects[id] = rect;
				return id;
			});

			_BoundedObject.prototype.prepare.call(this, context, instance);
		};

		_proto.prepareCleanup = function prepareCleanup(context, instance) {
			_BoundedObject.prototype.prepareCleanup.call(this, context, instance);

			context.pop("addClipRect");
		};

		_proto.render = function render(context, instance, key) {
			return VDOM.createElement(
				SvgComponent,
				{
					key: key,
					instance: instance,
					data: instance.data,
					options: context.options,
					size: instance.state.size
				},
				this.renderChildren(context, instance)
			);
		};

		return Svg;
	})(BoundedObject);
Svg.prototype.anchors = "0 1 1 0";
Svg.prototype.baseClass = "svg";
Svg.prototype.autoWidth = false;
Svg.prototype.autoHeight = false;
Svg.prototype.aspectRatio = 1.618;

function sameSize(a, b) {
	if (!a || !b) return false;
	return a.width == b.width && a.height == b.height;
}

var SvgComponent =
	/*#__PURE__*/
	(function(_VDOM$Component) {
		_inheritsLoose(SvgComponent, _VDOM$Component);

		function SvgComponent() {
			return _VDOM$Component.apply(this, arguments) || this;
		}

		var _proto2 = SvgComponent.prototype;

		_proto2.render = function render() {
			var _this = this;

			var _this$props = this.props,
				instance = _this$props.instance,
				data = _this$props.data,
				size = _this$props.size,
				children = _this$props.children;
			var widget = instance.widget;
			var defs = [];

			for (var k in instance.clipRects) {
				var cr = instance.clipRects[k];
				defs.push(
					VDOM.createElement(
						"clipPath",
						{
							key: k,
							id: k
						},
						VDOM.createElement("rect", {
							x: cr.l,
							y: cr.t,
							width: Math.max(0, cr.width()),
							height: Math.max(0, cr.height())
						})
					)
				);
			}

			var style = data.style;
			if (widget.autoHeight)
				style = _objectSpread({}, style, {
					height: size.height + "px"
				});
			if (widget.autoWidth)
				style = _objectSpread({}, style, {
					width: size.width + "px"
				}); //parent div is needed because clientWidth doesn't work on the svg element in FF

			return VDOM.createElement(
				"div",
				{
					ref: function ref(el) {
						_this.el = el;
					},
					className: data.classNames,
					style: style
				},
				size.width > 0 &&
					size.height > 0 &&
					VDOM.createElement("svg", null, VDOM.createElement("defs", null, defs), children)
			);
		};

		_proto2.onResize = function onResize() {
			var instance = this.props.instance;
			var widget = this.props.instance.widget;
			var size = {
				width: this.el.clientWidth,
				height: this.el.clientHeight
			};
			if (widget.autoHeight) size.height = size.width / widget.aspectRatio;
			if (widget.autoWidth) size.width = size.height * widget.aspectRatio;
			if (!sameSize(instance.state.size, size))
				instance.setState({
					size: size
				});
		};

		_proto2.componentDidMount = function componentDidMount() {
			this.offResize = ResizeManager.trackElement(this.el, this.onResize.bind(this));
			this.onResize();
		};

		_proto2.componentDidUpdate = function componentDidUpdate() {
			this.onResize();
		};

		_proto2.componentWillUnmount = function componentWillUnmount() {
			if (this.offResize) {
				this.offResize();
				delete this.offResize;
			}
		};

		return SvgComponent;
	})(VDOM.Component);

Widget.alias("svg", Svg);

var Rectangle =
	/*#__PURE__*/
	(function(_TextualBoundedObject) {
		_inheritsLoose(Rectangle, _TextualBoundedObject);

		function Rectangle() {
			return _TextualBoundedObject.apply(this, arguments) || this;
		}

		var _proto = Rectangle.prototype;

		_proto.declareData = function declareData() {
			var _TextualBoundedObject2;

			(_TextualBoundedObject2 = _TextualBoundedObject.prototype.declareData).call.apply(
				_TextualBoundedObject2,
				[this].concat(Array.prototype.slice.call(arguments), [
					{
						colorIndex: undefined,
						fill: undefined,
						stroke: undefined
					}
				])
			);
		};

		_proto.render = function render(context, instance, key) {
			var data = instance.data;
			var bounds = data.bounds,
				colorIndex = data.colorIndex;
			if (!bounds.valid()) return false;
			return VDOM.createElement(
				"g",
				{
					key: key,
					className: data.classNames
				},
				VDOM.createElement("rect", {
					className: this.CSS.element(this.baseClass, "rect", colorIndex != null && "color-" + colorIndex),
					x: bounds.l,
					y: bounds.t,
					width: bounds.width(),
					height: bounds.height(),
					style: data.style,
					fill: data.fill,
					stroke: data.stroke
				}),
				this.renderChildren(context, instance)
			);
		};

		return Rectangle;
	})(TextualBoundedObject);
Rectangle.prototype.baseClass = "rectangle";
Rectangle.prototype.anchors = "0 1 1 0";
Widget.alias("rectangle", Rectangle);

var ClipRect =
	/*#__PURE__*/
	(function(_BoundedObject) {
		_inheritsLoose(ClipRect, _BoundedObject);

		function ClipRect() {
			return _BoundedObject.apply(this, arguments) || this;
		}

		var _proto = ClipRect.prototype;

		_proto.prepareBounds = function prepareBounds(context, instance) {
			_BoundedObject.prototype.prepareBounds.call(this, context, instance);

			var data = instance.data;
			data.clipId = context.addClipRect(data.bounds);
		};

		_proto.render = function render(context, instance, key) {
			var data = instance.data;
			return VDOM.createElement(
				"g",
				{
					key: key,
					clipPath: "url(#" + data.clipId + ")"
				},
				this.renderChildren(context, instance)
			);
		};

		return ClipRect;
	})(BoundedObject);
ClipRect.prototype.anchors = "0 1 1 0";

var Ellipse =
	/*#__PURE__*/
	(function(_TextualBoundedObject) {
		_inheritsLoose(Ellipse, _TextualBoundedObject);

		function Ellipse() {
			return _TextualBoundedObject.apply(this, arguments) || this;
		}

		var _proto = Ellipse.prototype;

		_proto.declareData = function declareData() {
			var _TextualBoundedObject2;

			(_TextualBoundedObject2 = _TextualBoundedObject.prototype.declareData).call.apply(
				_TextualBoundedObject2,
				[this].concat(Array.prototype.slice.call(arguments), [
					{
						colorIndex: undefined,
						fill: undefined,
						stroke: undefined
					}
				])
			);
		};

		_proto.render = function render(context, instance, key) {
			var data = instance.data;
			var bounds = data.bounds,
				colorIndex = data.colorIndex;
			if (!bounds.valid()) return false;
			return VDOM.createElement(
				"g",
				{
					key: key,
					className: data.classNames
				},
				VDOM.createElement("ellipse", {
					className: this.CSS.element(this.baseClass, "rect", colorIndex != null && "color-" + colorIndex),
					cx: (bounds.l + bounds.r) / 2,
					cy: (bounds.t + bounds.b) / 2,
					rx: bounds.width() / 2,
					ry: bounds.height() / 2,
					style: data.style,
					fill: data.fill,
					stroke: data.stroke
				}),
				this.renderChildren(context, instance)
			);
		};

		return Ellipse;
	})(TextualBoundedObject);
Ellipse.prototype.baseClass = "ellipse";
Ellipse.prototype.anchors = "0 1 1 0";
Widget.alias("ellipse", Ellipse);

var Line =
	/*#__PURE__*/
	(function(_TextualBoundedObject) {
		_inheritsLoose(Line, _TextualBoundedObject);

		function Line() {
			return _TextualBoundedObject.apply(this, arguments) || this;
		}

		var _proto = Line.prototype;

		_proto.declareData = function declareData() {
			var _TextualBoundedObject2;

			(_TextualBoundedObject2 = _TextualBoundedObject.prototype.declareData).call.apply(
				_TextualBoundedObject2,
				[this].concat(Array.prototype.slice.call(arguments), [
					{
						colorIndex: undefined,
						stroke: undefined
					}
				])
			);
		};

		_proto.render = function render(context, instance, key) {
			var data = instance.data,
				colorIndex = instance.colorIndex;
			var bounds = data.bounds;
			return VDOM.createElement(
				"g",
				{
					key: key,
					className: data.classNames
				},
				VDOM.createElement("line", {
					className: this.CSS.element(this.baseClass, "line", colorIndex != null && "color-" + colorIndex),
					x1: bounds.l,
					y1: bounds.t,
					x2: bounds.r,
					y2: bounds.b,
					style: data.style,
					stroke: data.stroke
				}),
				this.renderChildren(context, instance)
			);
		};

		return Line;
	})(TextualBoundedObject);
Line.prototype.anchors = "0 1 1 0";
Line.prototype.baseClass = "line";
Widget.alias("line", Line);

export { BoundedObject, ClipRect, Ellipse, Line, Rect, Rectangle, Svg, Text, TextualBoundedObject };
